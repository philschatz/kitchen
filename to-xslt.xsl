<!--

Helpful references:

XSLT3.0: https://www.w3.org/TR/xslt-30/
XPath functions: https://www.w3.org/TR/xpath-functions-30/

-->

<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"
    xmlns:fn="http://www.w3.org/2005/xpath-functions"
    xmlns:h="http://www.w3.org/1999/xhtml"
    xmlns:r="urn:replacer-xml"
    xmlns:temp="urn:temp-placeholder-element"
    expand-text="yes"
    version="3.0">

<xsl:output method="xml" indent="yes"/>

<xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/>

<xsl:template match="/">
    <xsl:comment>This file is autogenerated. DO NOT EDIT.</xsl:comment>
    <xsl:apply-templates select="*"/>
</xsl:template>

<xsl:template match="r:root">
    <t:transform expand-text="yes" version="3.0" exclude-result-prefixes="r xs fn temp">
        <t:output method="xhtml" html-version="5"/>
        <t:mode use-accumulators="#all"/>
        <t:key name="link-target" match="*" use="@id"/>
        <t:key name="internal-id" match="*" use="@temp:id"/>
        <t:key name="internal-parent" match="*" use="@temp:parent"/>

        <xsl:comment>
            ===============================
            Explanation of the modes; they run in order:
            INITIALIZE_MODE: adds a unique @temp:id and @temp:parent to each element to support  r:link to="child"
            ANNOTATE_MODE: adds a unique @temp:replace-id to each element that is matched because the element may move so the selector will no longer apply
                (maybe this can be combined with INITIALIZE_MODE)
            EXPAND_MODE: replaces the current element with the elements defined in r:replace but does not evaluate any of the dump-counter or dump-bucket.
            MOVE_MODE: dumps the elements in the buckets out so they are now in the content
            NUMBER_MODE: dumps the counters out (which result in things being counted) and stores the target link text for an element (e.g. "Figure 4.3")
            LINK_MODE: populates links with autogenerated text based on what the target is
            CLEANUP_MODE: remove temporary attributes on elements
            ===============================
        </xsl:comment>
        <t:template match="/">
            <t:variable name="pipe"><t:apply-templates mode="INITIALIZE_MODE" select="@*|node()"/></t:variable>
            <t:variable name="pipe"><t:apply-templates mode="ANNOTATE_MODE" select="$pipe"/></t:variable>
            <t:variable name="pipe"><t:apply-templates mode="EXPAND_MODE" select="$pipe"/></t:variable>
            <t:variable name="pipe"><t:apply-templates mode="MOVE_MODE" select="$pipe"/></t:variable>
            <t:variable name="pipe"><t:apply-templates mode="NUMBER_MODE" select="$pipe"/></t:variable>
            <t:variable name="pipe"><t:apply-templates mode="LINK_MODE" select="$pipe"/></t:variable>
            <t:variable name="pipe"><t:apply-templates mode="CLEANUP_MODE" select="$pipe"/></t:variable>
            <t:sequence select="$pipe"/>
        </t:template>

        <xsl:apply-templates mode="ACCUMULATORS_MODE" select="//r:bucket"/>
        <xsl:apply-templates mode="ACCUMULATORS_MODE" select="//r:counter"/>

        <!-- Recurse -->
        <xsl:apply-templates select="node()"/>

        <xsl:comment>Preserve the tree hierarchy before things start to move around</xsl:comment>
        <t:template mode="INITIALIZE_MODE" match="*">
            <t:copy>
                <t:attribute name="temp:id" select="generate-id()"/>
                <t:attribute name="temp:parent" select="generate-id(..)"/>
                <t:apply-templates mode="INITIALIZE_MODE" select="@*|node()"/>
            </t:copy>
        </t:template>

        <xsl:comment>Identity Transform</xsl:comment>
        <t:template match="@*|node()"><t:copy><t:apply-templates select="@*|node()"/></t:copy></t:template>
        <t:template mode="INITIALIZE_MODE" match="@*|node()[not(self::*)]"><t:copy><t:apply-templates mode="INITIALIZE_MODE" select="@*|node()"/></t:copy></t:template>
        <t:template mode="ANNOTATE_MODE" match="@*|node()"><t:copy><t:apply-templates mode="ANNOTATE_MODE" select="@*|node()"/></t:copy></t:template>
        <t:template mode="EXPAND_MODE" match="@*|node()"><t:copy><t:apply-templates mode="EXPAND_MODE" select="@*|node()"/></t:copy></t:template>
        <t:template mode="MOVE_MODE" match="@*|node()"><t:copy><t:apply-templates mode="MOVE_MODE" select="@*|node()"/></t:copy></t:template>
        <t:template mode="NUMBER_MODE" match="@*|node()"><t:copy><t:apply-templates mode="NUMBER_MODE" select="@*|node()"/></t:copy></t:template>
        <t:template mode="LINK_MODE" match="@*|node()"><t:copy><t:apply-templates mode="LINK_MODE" select="@*|node()"/></t:copy></t:template>
        <t:template mode="CLEANUP_MODE" match="@*|node()"><t:copy><t:apply-templates mode="CLEANUP_MODE" select="@*|node()"/></t:copy></t:template>

        <!-- Remove temporary attributes -->
        <t:template mode="CLEANUP_MODE" match="@temp:replace-id | @temp:id | @temp:parent | @temp:linktext"/>

        <!-- boilerplate -->
        <t:template mode="NUMBER_MODE" match="r:dump-counter">
            <t:value-of select="accumulator-after(@name)"/>
        </t:template>

        <!-- When linking internally look up the link-text of the target element -->
        <t:template mode="LINK_MODE" match="h:a[starts-with(@href, '#')]">
            <t:variable name="targetId" select="substring-after(@href, '#')"/>
            <t:variable name="target" select="key('link-target', $targetId)"/>
            <t:if test="not($target)">
                <t:message terminate="yes">BUG: Could not find link target with id="{{$targetId}}"</t:message>
            </t:if>
            <t:copy>
                <t:apply-templates mode="LINK_MODE" select="@*"/>
                <t:value-of select="$target[1]/@temp:linktext"/>
            </t:copy>
        </t:template>

        <t:template mode="LINK_MODE" match="r:link[@to='parent']">
            <t:variable name="parentId" select="ancestor::*[@temp:parent][1]/@temp:parent"/>
            <t:if test="not($parentId)">
                <t:message terminate="yes">BUG: Could not find an ancestor of this link that has a @temp:parent assigned</t:message>
            </t:if>
            <t:variable name="parent" select="key('internal-id', $parentId)"/>
            <t:if test="not($parent)">
                <t:message terminate="yes">BUG: Could not find parent element with temp:id="{{$parentId}}"</t:message>
            </t:if>
            <t:if test="not($parent[1]/@id)">
                <t:message terminate="yes">This parent element does not have an id attribute on it yet. Autogenerating id attributes is not supported yet. {@selector}</t:message>
            </t:if>
            <h:a href="#{{$parent[1]/@id}}">
                <t:if test="not($parent/@temp:linktext)">
                    <t:message terminate="yes">Link target #{{$parent[1]/@id}} did not have a link-text element defined for it so do not know how to render the link</t:message>
                </t:if>
                <t:value-of select="$parent[1]/@temp:linktext"/>
            </h:a>
        </t:template>

        <xsl:for-each select=".//r:link[@to='child']">

            <t:template mode="LINK_MODE" match="r:link[@to='child'][@temp:child-link-key='{replace(@selector, &quot;'&quot;, '#')}']">
                <t:variable name="child" select="key('internal-parent', ancestor::*[@temp:id][1]/@temp:id)[self::{@selector}]"/>
                <t:if test="not($child[1]/@id)">
                    <t:message>{{count($child)}} elements</t:message>
                    <t:message terminate="no">This child element does not have an id attribute on it yet. Autogenerating id attributes is not supported yet. {@selector}</t:message>
                </t:if>
                <h:a href="#{{$child[1]/@id}}">
                    <t:if test="not($child/@temp:linktext)">
                        <t:message terminate="no">Link target #{{$child[1]/@id}} did not have a link-text element defined for it so do not know how to render the link</t:message>
                    </t:if>
                    <t:choose>
                        <t:when test="node()">
                            <t:apply-templates mode="LINK_MODE" select="node()"/>
                        </t:when>
                        <t:otherwise>
                            <t:value-of select="$child[1]/@temp:linktext"/>
                        </t:otherwise>
                    </t:choose>
                </h:a>
            </t:template>

        </xsl:for-each>

        <!-- The children of this node are matches explicitly -->
        <t:template mode="NUMBER_MODE" match="r:link-text"/>

        <!-- Do not copy comments into the link text. The comment will just show up as plain text in the link which is weird -->
        <t:template mode="NUMBER_MODE" match="r:link-text//comment()"/>

        <xsl:apply-templates mode="DECLARE_DUMPSITES" select=".//r:dump-bucket"/>
        <xsl:apply-templates mode="DECLARE_DUMPSITES" select=".//r:copy-content"/>

        <!-- <t:function name="temp:hasClass" as="xs:boolean">
            <t:param name="class" as="xs:string"/>
            <t:param name="className" as="xs:string"/>
            <t:sequence select="fn:exists(fn:index-of(fn:tokenize($class, '\s+'), $className))"/>
        </t:function>

        <t:function name="temp:addClass" as="xs:string">
            <t:param name="class" as="xs:string"/>
            <t:param name="className" as="xs:string"/>
            <t:value-of select="fn:normalize-space(fn:concat($class, ' ', $className))"/>
        </t:function> -->

    </t:transform>
</xsl:template>

<xsl:template match="r:replace">
    <xsl:variable name="matchString">
        <xsl:call-template name="build-match-with-self"/>
    </xsl:variable>
    <xsl:variable name="variablesDefined" select="r:count-value/@name"/>
    <xsl:variable name="variablesUsed" select="distinct-values(.//r:dump-counter/@name)"/>
    <xsl:variable name="templateId" select="generate-id()"/>
    <xsl:variable name="classMatchString">*[@temp:replace-id][@temp:replace-id = '{$templateId}']</xsl:variable>

    <t:template mode="ANNOTATE_MODE" match="{$matchString}">
        <t:copy>
            <t:attribute name="temp:replace-id">{$templateId}</t:attribute>
            <t:apply-templates mode="ANNOTATE_MODE" select="@*|node()"/>
        </t:copy>
    </t:template>

    <xsl:comment>@temp:replace-id='{$templateId}' is actually: {$matchString}</xsl:comment>
    <t:template mode="EXPAND_MODE" match="{$classMatchString}">
        <xsl:apply-templates select="node()[not(self::r:replace)]">
            <xsl:with-param tunnel="yes" name="currentMode">EXPAND_MODE</xsl:with-param>
            <xsl:with-param tunnel="yes" name="variablesDefined" select="$variablesDefined"/>
            <xsl:with-param tunnel="yes" name="variablesUsed" select="$variablesUsed"/>
        </xsl:apply-templates>
    </t:template>

    <xsl:choose>
        <xsl:when test="@move-to">
            <t:template mode="MOVE_MODE" match="{$matchString}">
                <t:comment>Moved "{$matchString}" because it had a @move-to</t:comment>
                <t:message>Removing element {$matchString} because it has a @move-to</t:message>
            </t:template>
        </xsl:when>
        <xsl:otherwise>
            <t:template mode="MOVE_MODE" match="{$matchString}">
                <t:copy>
                    <t:apply-templates mode="MOVE_MODE" select="@*|node()">
                        <t:with-param tunnel="yes" name="nearestReplacerContext" select="."/>
                    </t:apply-templates>
                </t:copy>
            </t:template>
        </xsl:otherwise>
    </xsl:choose>

    <t:template mode="NUMBER_MODE" match="{$classMatchString}">
        <xsl:for-each select="$variablesUsed">
            <t:param tunnel="yes" name="{.}"/>
        </xsl:for-each>
        <xsl:apply-templates select="r:count-value"/>
        <t:copy>
            <t:apply-templates mode="NUMBER_MODE" select="@*"/>
            <t:attribute name="temp:linktext">
                <t:apply-templates mode="NUMBER_MODE" select="r:link-text/node()">
                    <t:with-param tunnel="yes" name="nearestReplacerContext" select="."/>
                </t:apply-templates>
            </t:attribute>

            <xsl:call-template name="applyChildren">
                <xsl:with-param tunnel="yes" name="currentMode">NUMBER_MODE</xsl:with-param>
                <xsl:with-param tunnel="yes" name="variablesDefined" select="$variablesDefined"/>
                <xsl:with-param tunnel="yes" name="variablesUsed" select="$variablesUsed"/>
            </xsl:call-template>
        </t:copy>
    </t:template>

    <xsl:apply-templates select="r:replace">
        <xsl:with-param tunnel="yes" name="variablesDefined" select="$variablesDefined"/>
        <xsl:with-param tunnel="yes" name="variablesUsed" select="$variablesUsed"/>
    </xsl:apply-templates>
</xsl:template>


<xsl:template match="r:this">
    <xsl:comment>r:this</xsl:comment>
    <t:copy>
        <t:apply-templates select="@*"/>
        <xsl:if test="../r:declare/r:link-text">
            <r:link-text>
                <xsl:apply-templates select="../r:declare/r:link-text/node()"/>
            </r:link-text>
        </xsl:if>

        <xsl:apply-templates select="node()"/>
    </t:copy>
</xsl:template>

<xsl:template match="r:children" name="applyChildren">
    <xsl:param tunnel="yes" name="currentMode" as="xs:string"/>
    <xsl:param tunnel="yes" name="variablesDefined"/>
    <xsl:comment>r:children</xsl:comment>
    <t:apply-templates mode="{$currentMode}" select="node()">
        <xsl:for-each select="$variablesDefined">
            <t:with-param tunnel="yes" name="{.}" select="${.}"/>
        </xsl:for-each>
    </t:apply-templates>
</xsl:template>


<xsl:template match="r:link-text"/>

<xsl:template match="r:copy-content">
    <xsl:variable name="id" select="generate-id()"/>
    <xsl:copy>
        <xsl:attribute name="temp:id">COPY_CONTENT_{@name}_{$id}</xsl:attribute>
        <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
</xsl:template>
<xsl:template mode="DECLARE_DUMPSITES" match="r:copy-content">
    <xsl:variable name="id" select="generate-id()"/>
    <t:template mode="NUMBER_MODE" match="r:copy-content[@temp:id='COPY_CONTENT_{@name}_{$id}']">
        <t:param tunnel="yes" name="nearestReplacerContext" as="element()"/>
        <t:apply-templates mode="NUMBER_MODE" select="$nearestReplacerContext/{@selector}"/>
    </t:template>
</xsl:template>

<xsl:template match="r:dump-bucket">
    <xsl:variable name="id" select="generate-id()"/>
    <xsl:copy>
        <xsl:attribute name="temp:id">DUMP_BUCKET_{@name}_{$id}</xsl:attribute>
        <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
</xsl:template>

<xsl:template mode="DECLARE_DUMPSITES" match="r:dump-bucket[not(@group-by)]">
    <xsl:variable name="id" select="generate-id()"/>
    <t:template mode="MOVE_MODE" match="r:dump-bucket[@temp:id='DUMP_BUCKET_{@name}_{$id}']">
        <t:comment> r:dump-bucket[@name='{@name}'][not(@group-by)] DUMP_BUCKET_{@name}_{$id}</t:comment>
        <t:for-each select="accumulator-after('{@name}')">
            <!-- Ensure that the element is actually copied (not removed because it was moved). 
                    But ensure that the children are removed if they were also moved -->
            <t:copy>
                <t:apply-templates mode="MOVE_MODE" select="@*|node()"/>
            </t:copy>
        </t:for-each>
    </t:template>
</xsl:template>

<xsl:template mode="DECLARE_DUMPSITES" match="r:dump-bucket[@group-by]">
    <xsl:variable name="id" select="generate-id()"/>
    <t:template mode="MOVE_MODE" match="r:dump-bucket[@temp:id='DUMP_BUCKET_{@name}_{$id}']">
        <t:param tunnel="yes" name="nearestReplacerContext" as="element()"/>
        <t:comment> DUMP_BUCKET_{@name}_{$id} . Found {{count($nearestReplacerContext/{@group-by})}} groups to loop over</t:comment>
        <t:for-each select="$nearestReplacerContext/{@group-by}">
            <t:variable name="groupEl" select="."/>
            <t:variable name="title" select="{@group-by-title}"/>
            <h:div class="-i-am-a-group-by-block">
                <h:h3><h:a href="#{{$groupEl/@id}}">[this-will-be-replaced-with-autogen-linktext]</h:a></h:h3>

                <t:for-each select="accumulator-after('{@name}')">
                    <t:variable name="nearestGroupEl" select="ancestor::{@group-by}"/>
                    <t:if test="$groupEl[1] = $nearestGroupEl[1]">
                        <!-- Ensure that the element is actually copied (not removed because it was moved). 
                            But ensure that the children are removed if they were also moved -->
                        <t:copy>
                            <t:apply-templates mode="MOVE_MODE" select="@*|node()"/>
                        </t:copy>
                    </t:if>
                </t:for-each>
            </h:div>
        </t:for-each>
    </t:template>
</xsl:template>

<!--We have to hardcode the selector because XSLT Home Edition does not support dynamic selectors-->
<xsl:template match="r:link[@to='child']/@selector">
    <xsl:attribute name="temp:child-link-key" select="replace(., &quot;'&quot;, '#')"/>
</xsl:template>

<xsl:template mode="ACCUMULATORS_MODE" match="r:bucket">
    <xsl:variable name="name" select="@name"/>
    <xsl:variable name="resetMatchString">
        <xsl:call-template name="build-match-ancestors"/>
    </xsl:variable>
    <t:accumulator name="{@name}" initial-value="()">
        <t:accumulator-rule match="{$resetMatchString}" select="()"/>
        <xsl:for-each select="/r:root//r:replace[@move-to=$name]">
            <xsl:variable name="appendMatchString">
                <xsl:call-template name="build-match-with-self"/>
            </xsl:variable>
            <t:accumulator-rule match="{$appendMatchString}" select="$value union ."/>
        </xsl:for-each>
    </t:accumulator>
</xsl:template>

<xsl:template mode="ACCUMULATORS_MODE" match="r:counter">
    <xsl:variable name="name" select="@name"/>
    <xsl:variable name="resetMatchString">
        <xsl:call-template name="build-match-ancestors"/>
    </xsl:variable>
    <t:accumulator name="{@name}" initial-value="0">
        <t:accumulator-rule match="{$resetMatchString}" select="0"/>
        <t:accumulator-rule match="{@selector}" select="$value + 1"/>
    </t:accumulator>
</xsl:template>

<!-- Discard the declaration block. We no longer need it -->
<xsl:template match="r:declare"/>

<xsl:template name="build-match-with-self"><xsl:for-each select="ancestor::r:replace">//{@selector}</xsl:for-each><xsl:if test="@selector">//{@selector}</xsl:if></xsl:template>
<xsl:template name="build-match-ancestors"><xsl:for-each select="ancestor::r:replace">//{@selector}</xsl:for-each></xsl:template>


<!-- Identity Transform -->
<xsl:template match="@*|node()">
    <xsl:copy>
        <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
</xsl:template>

</xsl:stylesheet>